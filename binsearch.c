#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <limits.h>
#include "types.h"
#include "const.h"
#include "util.h"

// TODO: implement
int serial_binsearch(int sorted_list[], int min, int max, int x)
{
    if (max < min)
	{
        return -1;
	}    
	int mid = min + (max-min)/2;
    if (x<sorted_list[mid])
	{
        return serial_binsearch(sorted_list, min, mid-1,x);
	}
    else if (x > sorted_list[mid])
	{
        return serial_binsearch(sorted_list, mid+1, max,x);
	}
    else
	{
        return mid;
	}
}

// TODO: implement
int parallel_binsearch() 
{
    return 0;
}

int main(int argc, char** argv) 
{
    /* TODO: move this time measurement to right before the execution of each binsearch algorithms
     * in your experiment code. It now stands here just for demonstrating time measurement. */

	//clock first step
    struct timespec start, finish;
	double elapsed = 0;

	/* Get the wall clock time at start */
	clock_gettime(CLOCK_MONOTONIC, &start);


	
	printf("[binsearch] Starting up...\n");

	/* Get the number of CPU cores available */
	printf("[binsearch] Number of cores available: '%ld'\n", sysconf(_SC_NPROCESSORS_ONLN));

	// run the program
	int lista[20]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
	int resultado = serial_binsearch(lista,0,sizeof(lista)/sizeof(lista[0]),14);
	printf("La posicion del numero es: %d \n",resultado);



	int T = 0;
	int E = 0;
	int P = 0;
	int index;
	int c;

	opterr = 0;


	while ((c = getopt (argc, argv, "E:T:P:")) != -1)
		switch (c){
			case 'E':
				E = atoi(optarg);
				break;
			case 'P':
				P = atoi(optarg);
				break;
			case 'T':
				T = atoi(optarg);
				break;
			
			case '?':
				if (optopt == 'E' || optopt == 'P' || optopt == 'T')
				  fprintf (stderr, "Option -%c requires an argument.\n", optopt);
				else if (isprint(optopt))
				  fprintf (stderr, "Unknown option `-%c'.\n", optopt);
				else
				  fprintf (stderr,
					   "Unknown option character `\\x%x'.\n",
					   optopt);
				return 1;
			default:
				abort ();
			}


	printf ( "T = %d\nE = %d\nP = %d\n",T, E, P);

	for (index = optind; index < argc; index++)
		printf ("Non-option argument %s\n", argv[index]);

    /* TODO: start datagen here as a child process. */
	int p_id = fork();
    
    	if(p_id == 0)
	{
    	printf("%s%d\n","Son Process ID: ", getpid());
    	execlp("./datagen","./datagen",NULL);
    	}
    	else if (p_id<=0)
	{
    	printf("%s\n", "Error creating son process");
	}

    /* TODO: implement code for your experiments using data provided by datagen and your
     * serial and parallel versions of binsearch.
     * */

    /* TODO: connect to datagen and ask for the necessary data in each experiment round.
     * Create a Unix domain socket with DSOCKET_PATH (see const.h).
     * Talk to datagen using the messages specified in the assignment description document.
     * Read the values generated by datagen from the socket and use them to run your
     * experiments
     * */
	struct sockaddr_un addr;

	int fd,cl,rc;
	char buf[100];
	char *socket_path = "\0hidden";

	if (argc > 1) socket_path=argv[1];

	if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
	perror("socket error");
	exit(-1);
	}

	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	if (*socket_path == '\0') {
	*addr.sun_path = '\0';
	strncpy(addr.sun_path+1, socket_path+1, sizeof(addr.sun_path)-2);
	} else {
	strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path)-1);
	unlink(socket_path);
	}

	if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
	perror("bind error");
	exit(-1);
	}

	if (listen(fd, 5) == -1) {
	perror("listen error");
	exit(-1);
	}

	while (1) {
	if ( (cl = accept(fd, NULL, NULL)) == -1) {
	perror("accept error");
	continue;
	}

	while ( (rc=read(cl,buf,sizeof(buf))) > 0) {
	printf("read %u bytes: %.*s\n", rc, rc, buf);
	}
	if (rc == -1) {
	perror("read");
	exit(-1);
	}
	else if (rc == 0) {
	printf("EOF\n");
	close(cl);
	}
  }

	/* Get the wall clock time at finish */
	clock_gettime(CLOCK_MONOTONIC, &finish);

	/* Calculate time elapsed */
	elapsed = (finish.tv_sec - start.tv_sec);
	elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;

	/* Print the time elapsed (in seconds) */
	printf("Time elapsed running this program: ");
	printf("%lf\n", elapsed);

    
}
